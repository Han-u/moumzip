## 경매에서 트랜잭션 관리
- 시나리오: 호가 경매에서 트랜잭션이 몰린다고 했을 때, 최고가를 갱신하기 위해 몰리는 트랜잭션에 대한 처리를 어떻게 할 것인가?
- 데이터 일관성 유지 및 동시성 문제를 해결해야한다!


1. 낙관적 락킹(Optimistic Locking)
   - 낙관적 락킹은 데이터베이스에서 동시성 제어를 위해 사용되며, 일반적으로 @Version 어노테이션을 통해 구현됨. 데이터 엔티티에 버전 필드를 추가하여, 데이터가 변경될 때마다 이 버전 필드가 증가한다.
   - ApplicationLevel

1) 읽기: 엔티티를 읽을 때, 현재의 버전 번호를 읽음
2) 쓰기 : 데이터를 변경하고 저장할 때 엔티티의 현재 버전 번호를 확인해
3) 비교: 데이터베이스에 저장된 버전 번호와 엔티티의 버전 번호를 비교한다.
4-1) 성공: 두 버전 번호가 일치하면 저장하고 버전 번호를 증가
4-2) 실패: 불일치시 OptimisticLockException 발생.(다른 트랜잭션이 엔티티를 변경했다)


2. 비관적 락킹(Pessimistic Locking)
   - 비관적 락킹은 트랜잭션이 데이터를 수정하려고 할 때 해당 데이터를 잠금으로 설정하여 다른 트랜잭션이 동시에 접근하지 못하게 함.
   - DB레벨

사용 가능한 동작 방식
1) PESSIMISTIC_READ: 다른 트랜잭션이 읽기 작업을 수행할 수 있지만, 쓰기 작업은 불가능함.
2) PESSIMISTIC_WRITE: 다른 트랜잭션이 읽기와 쓰기 작업 모두 불가능함.

3. 분산 락킹(Distributed Locking)
   - 여러 서버에서 동시에 데이터를 수정하는 환경에서 일관성을 유지하기 위해 사용됨. Redis와 같은 분산 락 서비스를 활용하여 구현할 수 있음.

4. AOP를 사용한 재시도 로직 구현
   - 낙관적 락 충돌 시 트랜잭션을 재시도하는 로직을 AOP를 통해 구현함으로써 코드의 가독성과 유지보수성을 높일 수 있음.



