### 1) 엔티티에 @NotNull과 @Column(nullable=false)는 뭐가 다를까??
1. JPA에서의 유효성 검사
@NotNull 어노테이션: 객체의 유효성 검사
- 엔티티가 저장되거나 업데이트될 때 필드가 null이면 예외 
- DB not null과 별개
2. 데이터베이스에서의 NOT NULL 제약 조건
@Column(nullable = false): DB NOT NULL 
- 하지만 Application Level에서 확인X
- DB 요청 보낼 때 그 때 null이면 예외

### 2) 엔티티 필드에 원시 타입(Primitive Type) vs 래퍼 클래스(Wrapper Class)
1. 원시 타입
장점: 메모리 효율, 기본 값 제공, 래퍼 클래스보다 빠름.
단점: null 값 허용 불가

2. 래퍼 클래스
장점: null 값 허용(장?점?), 많은 메서드와 기능
단점: 메모리 사용량, 성능

- 데이터베이스의 컬럼이 nullable인 경우: 래퍼 클래스 사용 (Integer, Long, Boolean)
- 데이터베이스의 컬럼이 not null인 경우: 원시 타입 사용 (int, long, boolean)


### 3) delete insert vs update

갑자기 든 궁금증
Django orm 썼을 때 many to many 테이블을 delete insert했던 기억이 있는데,,, 둘이 뭐가 다를까

1. UPDATE  
장점  
성능: 기존 행의 일부 값을 변경하는 작업으로, 비교적 빠름. 특히 데이터의 양이 많지 않거나 인덱스가 잘 설계되어 있는 경우 성능이 좋음.
일관성 유지: 기존 행의 주 키를 변경하지 않기 때문에 참조 무결성 유지 쉬움
트랜잭션 관리: 단일 작업으로 트랜잭션 관리가 용이 & 롤백 시에도 간단함.

단점  
제약 조건 관리: 특정 제약 조건이나 트리거가 복잡한 경우, UPDATE 작업이 제약 조건을 위반할 가능성이 있음.(!)  
기록 관리: 기존 행을 덮어쓰므로, 변경 전의 데이터 기록을 유지하려면 별도의 로깅 또는 히스토리 관리가 필요함.

2. DELETE & INSERT  
장점  
데이터 히스토리: 기존 행을 삭제하고 새 행을 삽입하면 이전 데이터를 다른 테이블에 보관하거나, 삭제된 데이터를 히스토리로 관리하기가 용이  
구조 변경: 테이블 구조가 변경되거나 특정 열의 데이터 형식이 바뀌는 경우, DELETE & INSERT가 더 유연할 수 있음  

단점  
성능: DELETE와 INSERT를 각각 수행하는 것은 UPDATE보다 성능이 떨어질 수 있음. 특히 인덱스가 많은 테이블에서는 오버헤드가 더 크다  
트랜잭션 관리: 두 개의 작업으로 나누어지므로, 트랜잭션 관리가 더 복잡할 수 있다. 중간에 문제가 발생시 일관성 유지 어려움  
참조 무결성: DELETE는 외래 키 제약 조건을 위반할 수 있으므로, 참조 무결성을 유지하기가 어려울 수 있음.  

3. 선택할 때 고려사항  
UPDATE를 선택할 경우  
 -- >데이터의 일부만 변경하는 경우  
 --> 대량의 데이터 변경시  
DELETE & INSERT를 선택할 경우
 --> 테이블 구조적 변경하는 경우

결론  
==> 대부분의 경우에서는 UPDATE가 더 효율적이고 간단하다
